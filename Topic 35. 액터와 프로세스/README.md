# Topic 35. 액터와 프로세스
액터(actor)와 프로세스를 사용하면 흥미로운 방식으로 동시성을 구현할 수 있다. 공유 메모리 접근을 동기화하느라 고생할 필요도 없다.  
용어를 먼저 정의해 보자.  
 - '액터'는 자신만의 비공개 지역상태를 가진 독립적인 가상 처리 장치다. 각 액터는 우편함을 하나씩 보유하고 있다. 액터가 잠자고 있을때 우편함에 메시지가 도착하면 액터가 깨어나면서 메시지를 처리한다. 만약 우편함이 비어있으면 다시 잠든다. 메시지를 처리할 때 액터는 다른 액터를 생성하거나, 알고 있는 다른 액터에게 메시지를 보내거나, 다음 메시지를 처리할 때의 상태가 될 새로운 상태를 생성할 수 있다.
 - '프로세스'는 본래 더 일반적인 가상 처리기로, 보통 운영 체제가 동시성을 지원하기 위하여 구현한다. 프로세스를 사용할 때 마치 액터처럼 동작하도록 관례를 만들어 제한적으로만 사용할 수도 있는데, 이번 항목에서 이야기하는 프로세스란 바로 이렇게 제한한 것을 말한다.

## 액터는 언제나 동시성을 띈다.
액터의 정의에서 찾아볼 수 없는 것이 몇가지 있다.  
 - 액터를 관리하는 것이 하나도 없다. 계획을 세우거나 정보를 입력데이터에서 최종 결과로 바꾸는 과정을 조율하는 것이 없다.
 - 시스템이 저장되는 상태는 오직 메시지 그리고 각 액터의 지역 상태 뿐이다. 메시지는 수신자가 읽는 것 외에는 확인할 방법이 없고, 지역 상태는 액터 바깥에서는 접근이 불가능하다.
 - 모든 메시지는 일방향이다. 답장이란 개념은 없다. 액터에서 답장을 받고 싶다면 처음 메시지를 보낼때 답장 받을 주소를 메시지에 포함해 보내야한다. 답장 또한 결국 또하나의 메시지일 뿐이다.
 - 액터는 각 메시지를 끝날때까지 처리하고 중간에 다른일을 하지 않는다. 즉 한번에 하나의 메시지만 처리한다.

그 결과 액터들은 아무것도 공유하지 않으면서 비동기적으로 동시에 실행된다.  
물리적 프로세서가 넉넉하다면 각각 액터를 하나씩 돌릴수 있다. 프로세서가 하나뿐이라면 액터마다 컨텍스트를 전환해가며 실행시킬수 있다.  
어느쪽이든 액터에서 실행되는 코드는 동일하다.
> 공유상태 없는 동시성을 위해 액터를 사용하라.

## 간단한 액터
레스토랑 예시를 액터로 구현해보자. 이 경우에는 고객, 종업원, 진열장 이렇게 세가지 액터가 있다.  
전체 메시지 흐름은 다음과 같다.  
 - 외부에 있는 우리가 고객에게 배고프다는 상태를 보낸다.
 - 고객은 종업원에게 파이를 주문한다.
 - 종업원은 고객에게 파이를 주라고 진열장에 요청한다.
 - 진열장에 파이가 있으면 파이 한조각을 고객에게 보낸다. 종업원에게는 계산서에 추가하라고 알려준다.
 - 파이가 없으면 종업원에게 알려준다. 종업원은 고객에게 양해를 구한다.

자바스크립트와 Node.js용 액터 라이브러리인 Nact를 이용해 구현해보자.  
고객은 세가지 메시지를 받을수 있다.  
 - 파이를 먹고싶다(외부에서 보냄)
 - 테이블에 파이가 있습니다(진열장이 보냄)
 - 죄송합니다. 파이가 다 떨어졌습니다(종업원이 보냄)

코드는 다음과 같다
```Javascript
const customerActor = {
 '파이가 먹고 싶다': (msg, ctx, state) => {
   return dispatch(state.waiter,{ type: '주문', customer: ctx.self, wants: '파이' });
 },
 '테이블에 놓다': (msg, ctx, _state) => 
   console.log('${ctx.self.name}이(가) 테이블에 나타난 "${msg.food}"을(를) 보다.');
 '남은 파이 없음': (_msg, ctx, _state) =>
   console.log('${ctx.self.name}이(가) 부루퉁하다...');
};
```
흥미로운 부분은 '파이가 먹고 싶다' 메시지를 받을때인데, 이때는 종업원에게 메시지를 보낸다.
고객이 종업원 액터를 어떻게 알게 되는지는 잠시후에 보자.  
종업원의 코드는 다음과 같다.  
```Javascript
const waiterActor = {
 '주문': (msg, ctx, state) => {
   if(msg.wants == '파이') {
     dispatch(state.pieCase, { type: '한조각 꺼내기', customer: msg.customer, waiter: ctx.self});
   }
   else {
     console.log('${msg.wants}의 주문 방법을 알 수 없습니다.');
   }
 },
 '주문서에 추가': (msg, ctx) => 
   console.log('${msg.food}을(를) ${msg.customer.name} 의 주문서에 추가합니다.');
 '오류': (msg, ctx) => {
   dispatch(msg.customer, { type: '남은 파이 없음', msg: msg.msg });
   console.log('\n종업원이 ${msg.customer.name}에게 양해를 구합니다: ${msg.msg}.');
 }   
};
```
종업원이 주문 메시지를 고객에게 받으면 고객에 파이를 주문한건지 확인한다.  
파이가 맞으면 진열장에 요청을 보내는데, 이때 고객과 자신의 참조를 함께 보낸다.  
진열장은 진열된 파이 조각 배열 상태를 가지고 있는데, 처음에 어떻게 파이를 진열장에 넣는지는 곧 설명하겠다.  
종업원에게 한조각 꺼내기 메시지를 받으면 남은 파이조각이 있는지 확인한다.  
파이가 있으면 고객에게 전달하고, 종업원에게는 주문서에 기록하라고 알려준다.  
마지막으로 한조각이 줄어든 상태를 기록한다. 코드는 다음과 같다.
```Javascript
const pieCaseAcotr = {
 '한조각 꺼내기': (msg, context, state) => {
   if(state.slices.length == 0) {
     dispatch(msg.waiter, { type: '오류', msg: '남은 파이 없음', customer: msg.customer});
     return state;
   }
   else {
     var slice = state.slices.shift() + ' 파이 한 조각';
     dispatch(msg.customer, { type: '테이블에 놓다', food: slice });
     dispatch(msg.waiter, { type: '주문서에 추가', food: slice, customer: msg.customer });
     return state;
   }
 }
};
```
실제 상황에서는 다른 액터를 동적으로 생성하는 액터도 많이 보겠지만, 여기서는 단순하게 액터를 모두 수동으로 생성할 것이다.  
또한 각각 초기 상태도 넘겨줘야 한다.  
 - 진열장은 처음에 갖고 있을 파이 조각 리스트를 받는다.
 - 종업원에게는 진열장의 참조를 준다.
 - 고객에게는 종업원의 참조를 준다.

```Javascript
const actorSystem = start();

let pieCase = start_actor(
  actorSystem,
  'pie-case',
  pieCaseActor,
  { slices: ['사과', '복숭아', '체리']});

let waiter = start_actor(
  actorSystem,
  'waiter',
  waiterActor,
  {pueCase: pieCase});

let c1 = start_actor(actorSystem, 'customer1',
                     customerActor, {waiter: waiter});
let c2 = start_actor(actorSystem, 'customer2',
                     customerActor, {waiter: waiter});
```
실행시켜보자. customer1은 파이를 세조각 주문하고 customer2는 두조각을 주문한다.  
```Javascript
dispatch(c1, { type: '파이가 먹고 싶다' });
dispatch(c2, { type: '파이가 먹고 싶다' });
dispatch(c1, { type: '파이가 먹고 싶다' });
dispatch(c2, { type: '파이가 먹고 싶다' });
dispatch(c1, { type: '파이가 먹고 싶다' });
sleep(500)
  .then(() => {
     stop(actorSystem);
})
```
이제 코드를 실행시키면 액터들이 서로 통신하는것을 볼 수 있다. 메시지 순서는 아마 좀 다를것이다.
```
$ node index.js
customer1이(가) 테이블에 나타난 "사과 파이 한 조각"을(를) 보다.
customer2이(가) 테이블에 나타난 "복숭아 파이 한 조각"을(를) 보다.
종업원이 사과 파이 한 조각을(를) customer1의 주문서에 추가합니다.
종업원이 복숭아 파이 한 조각을(를) customer2의 주문서에 추가합니다.
customer1이(가) 테이블에 나타난 "체리 파이 한 조각"을(를) 보다.
종업원이 체리 파이 한 조각을(를) customer1의 주문서에 추가합니다.

종업원이 customer1에게 양해를 구합니다: 남은 파이 없음.
customer1이(가) 부루퉁하다...

종업원이 customer2에게 양해를 구합니다: 남은 파이 없음.
customer2이(가) 부루퉁하다...
```

## 드러나지 않는 동시성
액터 모델에서는 동시성을 다루는 코드를 쓸 필요가 없다. 공유된 상태가 없기 떄문이다.  
명시적으로 처음부터 끝까지 이걸 한 다음 저걸 하라 는 코드를 쓸 필요도 없다. 액터가 수신하는 메시지에 따라 알아서 실행되기 떄문이다.
이렇게 구성된 컴포넌트 들은 단일 프로세서든, 멀티 코어든, 여러 컴퓨터가 네트워크로 연결되어 있든 똑같이 잘 작동한다.

## 얼랭이 장을 마련하다
얼랭(Erlang)언어와 런타임은 액터 구현의 좋은 사례다.  
얼랭은 액터를 프로세스라고 부르는데 일반적인 운영 체제의 프로세스와는 다르다. 여기서 이야기하는 액터에 더 가깝다.  
얼랭의 프로세스는 가볍기 떄문에 컴퓨터 한대에서 수백만 개를 실행시킬 수 있고, 프로세스끼리 메시지를 보내서 통신한다.  
프로세스들은 각각 격리되어 있어서 상태를 공유하지 않는다.  
그렇다고 얼랭(얼랭의 후손인 앨릭서)에만 액터가 있는 것은 아니다.  
다른 대부분의 언어에도 액터 구현이 있다. 동시에 실행되는 작업을 구현할 때 액터를 사용하라.
