[# Topic 34. 공유 상태는 틀린 상태
한가지 예를 들어보자. 여러분이 만약 좋아하는 레스토랑에 방문해 종업원에게 애플 파이가 남아있는지 묻는다.  
종업원은 진열장을 확인해 한조각이 남아 있는것을 확인하고 그렇다고 대답한다. 여러분은 주문을 마치고 안심한다.  
한편 반대쪽에도 다른 고객이 종업원에게 같은 질문을 하고, 이 종업원도 진열장을 확인한 후 주문을 받는다.  
이제 두 고객중 한명은 실망하게 될것이다.  
이 문제는 상태가 공유된 것이다. 종업원들은 서로를 고려하지 않고 진열장만을 확인했다.  

## 비-원자적 갱신
위 예시를 코드로 표현해보자
![KakaoTalk_20230904_004815648](https://github.com/jhkman/ProgramProgrammingProgrammer/assets/50142323/cbe570b9-ad00-42b0-b64d-abfc890a80e0)
두 종업원이 동시에(실생활에서는 병렬적으로) 작업을 한다. 코드를 보자
```
if display_case.pie_count > 0    # 진열장의 파이 조각수를 확인
  promise_pie_to_customer()      # 고객에게 파이를 약속
  display_case.take_pie()        # 진열장에서 파이를 획득
  give_pie_to_customer()         # 고객에게 파이 전달
end
```
여기서 문제는 두 프로세스가 같은 메모리 영역에 쓰기가 가능하다는 점이 아니다.  
문제는 어느 프로세스도 자신이 보는 메모리가 일관되어 있음을 보장할 수 없다는 점이다.  
종업원이 display_case.pie_count를 실행하는 것은 진열장의 값을 자신의 메모리로 복사하는 것이다.  
만약 진열장의 값이 바뀐다면 종업원의 메모리, 즉 결정에 사용한 메모리는 시효가 지난것이다.  
이것은 모두 파이조각을 가져오고 갱신하는 동작이 원자적(atomic)이지 않기 때문이다. 실제 값이 그 사이에 바뀔 수 있다.  

## 세마포어 및 다른 상호 배제 방법
세마포어(semaphore)는 단순히 한번에 한사람만이 가질 수 있는 무언가다.  
우리는 세마포어를 만들어서 다른 리소스의 사용을 제어하는 데 쓸 수 있다. 위에서는 진열장 사용을 제어하기 위해 세마포어를 쓸 수 있다.  
진열장의 내용물을 바꾸고 싶은 사람은 세마포어를 소유하고 있을때만 바꿀 수 있다는 규칙을 도입하는 것이다.  
여기서는 물리적인 세마포어로 문제를 해결해보자. 진열장위에 인형을 올려둔다. 모든 종업원은 주문을 받기 전에 인형을 손에 넣어야 한다.  
주문을 받고 파이를 고객에게 낸 후에는 인형을 파이를 지키는 원래 위치에 되돌려 놓는다.  
코드로 살펴보자.
```
case_semaphore.lock()

if display_case.pie_count > 0    # 진열장의 파이 조각수를 확인
  promise_pie_to_customer()      # 고객에게 파이를 약속
  display_case.take_pie()        # 진열장에서 파이를 획득
  give_pie_to_customer()         # 고객에게 파이 전달
end

case_semaphore_unlock()
```
두 종업원이 동시에 코드를 실행한다고 가정할 때, 둘다 세마포어를 얻으려고(lock) 시도하지만 한명만 성공한다.  
세마포어를 얻은쪽은 평소처럼 진행하지만, 얻지 못한 쪽은 얻을수 있을때 까지 기다린다.  
첫번째 종업원이 주문을 완료하면 다른 종업원이 실행을 재개한다.  
이 방식은 몇가지 문제가 있는데, 가장 큰 문제는 진열장에 접근하는 모든 사람이 빠짐없이 세마포어를 사용해야 제대로 동작한다는 것이다.  
즉 어떤 개발자가 약속을 지키지 않는 코드를 쓴다면 다시 혼돈에 빠진다.  

## 리소스를 트랜잭션으로 관리하라
이 설계가 미흡한 것은 진열장 사용을 보호할 책임을 진열장을 사용하는 사람에게 전가하기 떄문이다.  
제어를 중앙으로 집중시키자. 종업원이 하나의 호출로 파이조각 수를 확인함과 동시에 파이 조각을 가져가도록 만들어야 한다.  
```
slice = display_case.get_pie_if_available()
if slice
  give_pie_to_customer()
end
```
이렇게 하려면 실행되는 메서드를 진열장 자체에 넣어야 한다.  
```
def get_pie_if_available()
  if @slices.size > 0
    update_sales_data(:pie)
    return @slices.shift
  else
    return false
  end
end
```
이 코드는 리소스 접근을 한곳으로 모으긴 했지만, 이 메서드 자체도 여러개의 스레드에서 동시에 호출 될 수 있으므로 여전히 세마포어로 보호해야 한다.
```
def get_pie_if_available()
  @case_semaphore.lock()

  if @slices.size > 0
    update_sales_data(:pie)
    return @slices.shift
  else
    return false
  end

  @case_semaphore.unlock()
end
```
하지만 이 코드도 문제가 있는데, 만약 update_sales_data가 예외를 발생시키면 세마포어는 영영 lock이 풀리지 않을 것이고,  
이후 진열장에 접근하면 하염없이 대기하게 될것이다. 이 문제를 해결해야 한다.  
```
def get_pie_if_available()
  @case_semaphore.lock()

  try {
    if @slices.size > 0
      update_sales_data(:pie)
      return @slices.shift
    else
      return false
    end
  }
  ensure {
    @case_semaphore.unlock()
  }
end
```

## 여러 리소스와 트랜잭션
레스토랑에 아이스크림 냉동고를 설치했다. 고객이 파이와 아이스크림을 동시에 사용하는 메뉴(애플파이 알라모드 라고 하자)를 주문시, 종업원은 둘다 있는지 확인해야 한다.  
이 코드는 다음과 같다.  
```
slice = display_case.get_pie_if_available()
scoop = freezer.get_ice_cream_if_available()

if slice && scoop
  give_order_to_customer()
end
```
하지만 이코드는 제대로 동작하지 않는다. 파이를 꺼낸 후 아이스크림을 꺼내려 보니 아이스크림이 없다면?  
이 고객은 반드시 아이스크림도 필요로 한다. 그리고 파이가 이미 우리 손에 있기에 아이스크림없이 파이만 원하는 고객도 그 파이를 받을 수 없다.  
이 문제는 진열장에 파이를 다시 반환하는 메소드를 추가하여 해결 할 수 있다. 리소스를 계속 차지하고 있지 않도록 예외 처리를 추가하자.  
```
slice = display_case.get_pie_if_available()

if slic
  try {
    scoop = freezer.get_ice_cream_if_available()
    if scoop
     try {
       give_order_to_customer()
     }
     rescue {
       freezer.give_back(scoop)
     }
  }
  rescue {
    display_case.give_back(slice)
  }
end
```
이상적인 코드는 아니다. 코드가 지저분하고 실제 무슨일을 하는지 알아보기 어렵다.  
앞선 예에서는 리소스 관리 코드를 리소스 클래스 안으로 옮겨서 문제를 해결했지만 여기서는 리소스가 두가지다.  
코드를 진열장으로 옮겨야 할까 냉동고로 옮겨야 할까? 둘다 정답이 아닌것 같다.  
실용주의적 접근 방법은 애플파이 알라모드 자체도 리소스로 보는것이다.  
이 코드를 새로운 모듈로 옮기고, 클라이언트는 그냥 '아이스크림 올린 애플파이 주세요' 라고 요철할 수 있어야 한다. 결과는 성공 아니면 실패뿐이다.  
물론 실상황에서는 이런 조합 메뉴가 더 많을것이고, 메뉴마다 새로운 모듈을 만들고 싶지는 않을 것이다.  
대신 자신의 구성요소에 대한 참조들을 갖고 있는 메뉴 항목이 있고, 또 그 구성요소 각각이랑 자원을 주고받는 일반화된 get_menu_item 메소드가 있는 편이 나을 것이다.  

## 트랜잭션이 없는 갱신
공유 메모리는 동시성 문제의 원인으로 많이 지목받는다.  
하지만 수정 가능한 리소스를 공유하는 애플리케이션 코드 어디에서나 동시성 문제가 발생할 수 있다.  
가끔은 이런 리소스가 그다지 명백하지 않을 수도 있다. 필자는 스레드를 사용해 책의 빌드 도구를 더 많이 병렬화 했다는데, 빌드가 실패했다고 한다.  
그것도 매번 다른 곳에서 이상한 방식으로 실패했다 한다. 오류가 발생한 경우에는 늘 스레드가 파일이나 디렉터리를 찾지 못한다는 것을 발견했다고 한다.  
하지만 병렬로 처리 할떄는 한 스레드가 작업 디렉터리를 바꿔서 임시 작업 디렉터리에 있는 도중에 다른 스레드가 작동을 시작할 수 있었다고 한다.  
이 스레드는 작업 디렉터리가 원래 디렉터리일 것이라고 가정했지만, 스레드들은 현재 작업 디렉터리 값을 공유하므로 이 가정이 어긋나게 되었다.  
> 불규칙한 실패는 동시성 문제인 경우가 많다.

## 그 밖의 독점적인 접근
대부분의 언어에는 공유 리소스에 독점적으로 접근하는 것을 도와주는 라이브러리가 있다. 하지만 언어 자체에 동시성 지원이 들어있는 언어도 있다.  
함수형 언어들은 모든 데이터를 변경 불가능하게 만드는 경향이 있으므로 동시성 문제를 단순하게 만든다고 주장할 수도 있겠다.  
하지만 함수형 언어도 언젠가는 모든 것이 변경 가능한 진짜 세상에 발을 들여야 하므로 똑같은 문제를 겪는 순간이 올 것이다.  

## 의사 선생님 아파요...
이것 하나만 기억하자. 리소스를 공유하는 환경에서 동시성은 어렵다. 이 문제를 직접 풀려고 한다면 고난의 연속일 것이다.  
이어지는 두 항목에서는 이런 고통 없이 동시성의 이득을 취할 수 있는 대안을 제안한다.  
