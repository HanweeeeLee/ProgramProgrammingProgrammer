# Topic 28. 결합도 줄이기

높은 결합도는 변경의 적이다.  
우리는 코드에서 나타나는 다음과 같은 결합의 증상을 놓치지 않도록 주의해야 한다.  
 - 관계없는 모듈이나 라이브러리 간의 희한한 의존 관계
 - 한 모듈의 '간단한' 수정이 이와 관계없는 모듈을 통해 시스템 전역으로 퍼져나가거나 시스템의 다른 곳에서 무언가를 깨뜨리는 경우
 - 개발자가 수정하는 부분이 시스템에 어떤 영향을 미칠지 몰라 코드의 수정을 두려워하는 경우
 - 변경 사항에 누가 영향을 받는지 파악하고 있는 사람이 없어서 결국 모든 사람이 참석해야 하는 회의

## 열차사고 : 연쇄 메서드 호출
다음의 코드를 보자
```
public void applyDiscount(customer, order_id, discount) {
  totals = customer
           .orders
           .find(order_id)
           .getTotals();
  totals.grandTotal = totals.grandTotal - discount;
  totals.discount = discount;
}
```
고객 객체에서 해당하는 주문 컬렉션의 참조를 얻는다. 거기서 특정한 주문을 찾고, 찾은 주문의 합계(total)를 얻는다.  
이 합계에서 얻은 주문 총액(grandTotal)에서 할인액(discount)를 빼고 합계에 저장된 할인액도 갱신한다.  
이 코드는 총 5단계까지의 추상화를 오가는데, 결국 최상위 코드가 모든것을 알아야 하고, 설상가상 이 코드를 계속 지원하기 위해 앞으로 바꾸면 안되는 것도 너무 많다.  
메서드나 속성들이 모두 연결되어 있는데 이런 상태를 '열차사고' 라고 부른다.  
예를들어 사업부서에서 할인율을 최대 40%로 제한하기로 했다고 가정했을때 이 규칙을 반영하는 코드를 어디에 넣어야 할까?  
위에 작성되어있는 applyDiscount 함수에 넣어야 할것같지만, 문제는 지금 형태의 코드에서는 그것으로 충분한지 알수가 없다.  
어떤곳에 있는 코드든 totals 객체의 필드값을 바꿀 수 있을 것인데, 필드값을 바꾸는 다른 코드의 담당자에게도 새로운 요구사항이 제대로 전달되지 않는다면,  
규칙에 구멍이 생기게 될것이다.  
다른 의미로 책임의 문제라고도 볼수 있다. 당연히 totals 객체가 합계를 관리하는 책임을 저야 하지만 그렇게 하지 않고 있다.  
실제로는 누구나 갱신할수 있는 다수의 필드를 가진 컨테이너일 뿐이기 때문이다.  
이를 고치려면 다음의 원칙을 적용해야 한다.  

> 묻지 말고 말하라

이 원칙은 다른 객체의 내부 상태에 따라 판단을 내리고 그 객체를 갱신해서는 안된다는 것이다.  
객체의 내부 상태를 묻는것으로 인해 캡슐화의 장점은 완전히 사라지게 되고, 구현에 대한 지식이 코드 여기저기로 퍼지게 된다.  
따라서 열차사고를 고치는 첫발짝은 할인 처리를 totals 객체에 위임하는 것이다.  
```
public void applyDiscount(customer, order_id, discount) {
  customer
    .orders
    .find(order_id)
    .getTotals()
    .applyDiscount(discount);
}
```
마찬가지의 문제가 customer 객체와 주문 컬렉션에도 있다. 고객객체에서 바로 주문객체를 얻어오게 하자.  
```
public void applyDiscount(customer, order_id, discount) {
  customer
    .findOrder(order_id)
    .getTotals()
    .applyDiscount(discount);
}
```
마찬가지로 주문객체와 합계에도 적용해보면, 주문객체를 구현할 때 합계를 별도의 객체에 저장했다는 사실을 숨기자.  
```
public void applyDiscount(customer, order_id, discount) {
  customer
    .findOrder(order_id)
    .applyDiscount(discount);
}
```
위 코드에서는 고객과 주문이 최상위 개념이다. 주문을 고객객체 안에 완전히 숨기는 것은 좀 이상할 수도 있다.  
따라서 주문 객체를 노출하는 API를 만들어도 문제는 없다.  

### 데메테르 법칙
데메테르 법칙이란 80년대 말 이안 홀랜드가 만든 일련의 지침인데 보다 깨끗하고 결합도가 낮은 함수를 작성하는 방법을 알려준다.  
데메테르 법칙은 어떤 클래스 C에 정의된 메서드가 다음 항목에 속하는 것만 사용할 수 있다고 제한한다.  
 - C의 다른 인스턴스 메서드
 - 메서드의 매개 변수
 - 스택이나 힙에 자신이 생성하는 객체의 메서드
 - 전역 변수

이 법칙은 실제로 사용하기는 꽤 어렵다. 하지만 기반이 되는 원칙 자체는 유효하다. 이 말들을 쉬운 표현으로 바꾸자면  

> 메서드 호출을 엮지 말라

무언가에 접근할 때 "."을 딱 하나만 쓰려고 노력해 보라. 이런 규칙을 점 하나 규칙이라 부른다.  
점 하나 규칙에는 큰 예외가 하나 있는데, 엮는 것들이 절대로 바뀌지 않을것 같다면 이 규칙을 지키지 않아도 된다.  
사실 우리의 애플리케이션에 있는 것은 모두 바뀌리라 생각하는게 맞지만, 언어에 기본 포함된 라이브러리라면 꽤 안정적일 것이고, 다음처럼 사용해도 상관없다.  
```Ruby
people
  .sort_by{|person| person.age}
  .first(10)
  .map{|person| person.name}
```
위 루비 코드는 이책의 초판이 나왔던 20년전에도 동작했고 지금도 여전히 잘 동작한다.

### 연쇄와 파이프라인
추후 나올 내용중 함수를 조합하여 파이프라인을 만드는 방법이 나오는데, 이 파이프라인은 함수에서 함수로 데이터를 넘겨가며 변환한다.  
이런 파이프라인은 메서드 호출로 이루어진 열차사고와는 다르다. 수며겨진 구현 세부사항에 의존하지 않기 때문이다.  
그렇지만 파이프라인이 결합을 하나도 만들지 않는 것은 아니다. 파이프라인의 함수에서 반환하는 데이터는 반드시 다음 함수가 처리할 수 있는 형식이어야 한다.  
이런 파이프라인 형태의 결합은 열차 사고로 인한 결합에 비해 코드를 바꿀때 문제가 생기는 경우가 적었다고 한다.  

## 글로벌화의 해악 : 정적인 것의 위험함
어디서나 접근가능한 전역 데이터는 교묘하게 애플리케이션 컴포넌트 간의 결합을 만들어 낸다.  
전역 데이터 하나하나는 애플리케이션의 모든 메서드에 갑자기 매개변수가 추가된 것과 같은 효과를 낸다. 모든 메서드 안에서 사용할 수 있기 때문이다.  

> 전역 데이터를 피하라!

### 싱글톤도 전역 데이터다
앞서 일부러 전역 변수가 아닌 전역 데이터라고 계속 말하였다.
우리의 코드에 있는것이 싱글톤뿐이더라도, 외부로 노출된 인스턴스 변수가 잔뜩 있는 싱글톤은 여전히 전역데이터일 뿐이고 그저 이름이 길어졌을 뿐이다.

### 외부리소스도 전역 데이터다
수정 가능한 외부 리소스는 모두 전역 데이터이다.  
우리의 애플리케이션이 DB나 저장소, 파일 시스템, 서비스 API 등을 사용한다면 전역데이터의 함정에 빠질 위험이 있다.  
여기서의 해법은 이 리소스들을 우리가 작성하는 코드로 모두 감싸는 것이다.  


## 상속은 결합을 늘린다 : 왜 클래스 상속이 위험한가?
상속으로 다른 클래스의 상태와 행동을 그대로 가져올수 있다.  
상속을 잘못 사용하는 문제는 너무 중요해서 추후 따로 정리한 부분이 나오니 그때 참고하자.  

## 결국은 모두 ETC
직접적으로 아는 것만 다루는 부끄럼쟁이 코드를 게속 유지하라. 그러면 애플리케이션의 결합도를 낮게 유지할수 있을 것이고, 결과적으로 코드를 바꾸기 쉬워질 것이다.  
