# Topic 39. 알고리즘의 속도
## 알고리즘을 추정한다는 말의 의미
매우 간단한 몇 알고리즘을 제외한 대부분의 알고리즘은 가변적인 입력 데이터를 다룬다.  
일반적으로 입력의 크기는 알고리즘에 영향을 주는데, 입력의 크기가 클수록 알고리즘의 수행시간이 길어지거나 사용하는 메모리 양이 늘어난다.  
이런 관계가 늘 1차 함수처럼 선형적이라면 이 항목은 중요하지 않을것이다. 하지만 중요한 알고리즘은 대부분 선형적이지 않다.  
좋은 소식은 많은 알고리즘의 증가폭이 선형보다 작다는 것이고, 나쁜 소식은 나머지 알고리즘들은 증가 폭이 선형보다 훨씬 크다는 것이다.  
우리는 반복문이나 재귀 호출을 담고 있는 호출을 담고 있는 코드를 작성할때면 언제나 무의식적으로 수행시간과 필요한 메모리 양을 계산한다.  
정식 계산이라기 보단 우리가 하는 말이 되는지 가볍게 확인해 보는 정도에 가깝다.  
하지만 생각보다 상세한 분석을 해야하는 경우도 종종 있는데, 이럴때 대문자 O 표기법이 유용하다.  

## 대문자 O 표기법
대문자 O 표기법은 근삿값을 다루는 수학적 방법으로 O()와 같이 표기한다.  
O() 표기법은 우리가 측정하는 값(시간, 메모리 등)의 상한을 기술하는 표기법이다.  


## 상식으로 추정하기
상식을 이용해서 간단한 알고리즘들의 차수를 대부분 추정할 수 있다.  

### 단순 반복문
단순 반복문 하나가 1부터 n까지 돌아간다면 수행시간은 n에 비례해서 증가한다.  

### 중첩 반복문
반복문 안에 또 반복문이 들어 있다면, 알고리즘은 O(m * n)이 되며, 여기서 m과 n은 두 반복문의 반복 횟수다.  
이런 상황은 보통 버블 정렬처럼 간단한 정렬 알고리즘에서 나타나는데, 여기서 바깥쪽 반복문은 배열의 각 원소를 차례대로 방문하고,  
안쪽 반복문은 그 원소를 정렬된 결과 중 어디에 둘것이지 찾는다.  

### 반씩 자르기
반복문을 돌 때마다 작업 대상의 수를 반으로 줄여나가는 알고리즘 이라면 로그적 알고리즘 즉 O(lgn)이 될 가능성이 크다.

### 분할 정복
입력 데이터를 둘로 나눠서 각각 독립적으로 작업한 다음, 결과를 합치는 알고리즘은 O(nlgn)이 될 가능성이 크다.  
정렬된 목록의 이진 검색이나 이진 트리의 탐색, 정수의 2진수 표현에서 첫번째 1인 비트를 찾는 문제 등이 있다.

### 조합적
알고리즘이 항목의 순열을 다루기 시작하면 대부분의 경우 수행시간은 걷잡을 수 없이 늘어난다.  
순열에는 계승(! : factorial)이 따라오기 때문이다.  
원소 5개를 처리하는 조합적 알고리즘의 시간을 재본 후, 원소 6개를 처리해보면 시간이 6배나 더 걸리게 된다.  
원소 7개를 처리해보면 42배 걸린다. 일반적으로 난해 하다고 분류되는 문제를푸는 알고리즘이 여기에 속한다.  

## 실전에서의 알고리즘 속도
회사에서는 대개 정렬 루틴을 작성하느라 시간을 많이 쓰지 않는다.  
이미 나와있는 라이브러리에 들어 있는 정렬 루틴이 상당한 노력을 들이지 않는 한 대부분 우리가 작성하는 것보다 성능이 더 잘 나올 것이다.  
코드의 실행시간이 얼마나 될지 또는 메모리를 얼마나 사용할 지 확실하지 않다면 직접 실행해보고, 어떤 일을 하는 코드인지 코드 자체에 대해서도 생각해 보라.  
이론적인 요인과 실무적인 요인을 모두 고려하려고 노력하라.  
추정을 이미 했다고 하더라도 실제 서비스에서 데이터로 돌아가는 코드의 수행시간만이 정말로 의미있는 수치다.  
정확하게 시간을 재는 일이 어렵다면 '코드 프로파일러'를 사용해보는 것도 좋다.  

### 최고라고 언제나 최고는 아니다
적당한 알고리즘을 선택할 때도 실용적이어야 할 필요가 있다.  
빠른 알고리즘이 언제나 가장 좋은 알고리즘은 아니다. 입력값의 규모가 작다면 단순한 삽입 정렬도 퀵 정렬과 비슷한 성능을 낸다.  
그러나 삽입 정렬을 작성하고 디버깅하는 데 걸리는 시간은 퀵 정렬보다 적다.  
우리가 선택한 알고리즘이 요구하는 형식으로 입력 데이터를 준비하는데 비용이 많이 드는것은 아닌지 주의깊게 보아야 한다.  
그리고 '성급한 최적화'를 조심하라. 어떤 알고리즘을 개선하느라 시간을 투자하기 전에 그 알고리즘이 정말로 병목인지 먼저 확인하는 것이 좋다.
