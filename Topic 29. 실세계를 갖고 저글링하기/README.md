# Topic 29. 실세계를 갖고 저글링하기
우리가 작성하는 애플리케이션은 맡은 일을 어떻게든 수행해야 한다.  
이번장은 반응적인(Responsive) 애플리케이션을 작성하는 법을 다룬다.  

## 이벤트
이벤트는 무언가 정보가 있다는것을 의미한다.  
어디에서 온 것이든 애플리케이션을 이런 이벤트에 반응하도록, 그에 기반해서 하는 일을 조절하도록 만들면 더 잘 작동하는 애플리케이션이 탄생할 것이다.  
어떻게 이벤트에 잘 반응하는 애플리케이션을 만들수 있을까? 우리를 도와줄 네가지 전략을 살펴보자
1. 유한 상태 기계
2. 감시자(Observer) 패턴
3. 게시-구독
4. 반응형 프로그래밍과 스트림

### 유한상태 기계(Finite State Machine, FSM)

#### 실용주의 FSM 해부학
기본적으로 상태 기계는 이벤트를 어떻게 처리할지 정의한 명세일 뿐이다.  
정해진 상태들이 있고 그중 하나가 '현재 상태'다. 상태마다 그 상태일 때 의미가 있는 이벤트들을 나열하고, 이벤트별로 시스템의 다음 '현재 상태'를 정의한다.  
예를들어 여러 조각으로 나뉜 메시지를 웹소켓으로 받는다고 할떄, 첫번째 메시지는 헤더다. 그 다음에는 데이터 메시지가 몇개든 올수 있다.  
마지막으로 끝을 나타내는 트레일러 메시지가 온다 이를 FSM으로 표현해보면 다음과 같다.  
![KakaoTalk_20230808_233051268](https://github.com/jhkman/ProgramProgrammingProgrammer/assets/50142323/79802a34-df61-4063-8b19-c4ec36cdec6b)
'초기 상태' 에서 시작해서, 헤더 메시지를 받으면 '메시지 수신 중'상태로 이행한다.  
별표가 붙은 선은 초기상태에서 헤더가 아닌 메시지를 받으면 '오류' 상태로 이행하고 끝난다는 것이다.  
'메시지 수신 중'상태에서는 두가지 메시지를 받을수 있는데, 데이터 메시지를 받으면 현 상태에서 계속 메시지를 받고, 트레일러 메시지를 받으면 '완료' 상태로 이행한다.  
그밖의 다른 메시지를 받으면 '오류' 상태로 이행한다.  
FSM의 장점은 FSM을 오로지 데이터만으로 표현할 수 있다는 것이다.  
![KakaoTalk_20230808_233447804](https://github.com/jhkman/ProgramProgrammingProgrammer/assets/50142323/fa8403b3-3dcb-4675-bdfd-ce8deebb4d23)
각 행은 상태를 나타낸다. 이벤트 처리 방법을 알아내려면 먼저 현재 상태를 나타내는 행을 찾은 다음 발생한 이벤트를 나타내는 열을 찾으면 된다.  
찾은 칸의 내용이 다음 상태다. 코드로 표현해도 똑같이 간단하다.
```Ruby
TRANSITIONS = {
  initial: {header: : reading},
  reading: {data: :reading, trailer: :done}
}

state = :initial

while state != :done && state != :error
  msg = get_next_message()
  state= TRANSITIONS[state][msg.msg_type] || :error
end
```
상태간의 이행을 구현하는 코드는 열번째 줄이다. 상태이행 표에서 현재 상태를 먼저 찾고, 그 안에서 메시지 타입을 다시 찾아서 새로운 상태를 구했다.  
만약 해당하는 상태가 없다면 상태는 :error로 바뀐다.  

#### 상태 기계는 시작일 뿐
상태기계가 이벤트와 관련된 모든 문제를 해결하지는 못한다. 그러니 이벤트로 곡예를 펼치는 다른 방법으로 넘어가보자.  

### 감시자 패턴
'감시자 패턴'은 이벤트를 발생시키는쪽인 '감시 대상'과 이런 이벤트에 관심이 있는 클라이언트인 '감시자'로 이루어진다.  
감시자는 자신이 관심 있는 이벤트를 감시 대상에 등록한다. 보통은 호출될 함수의 참조도 등록할때 함께 넘긴다.  
나중에 해당 이벤트가 발생시 감시대상은 등록된 감시자 목록을 보면서 함수들을 일일히 호출한다. 이때 발생한 이벤트를 감시자 함수의 인자로 넘긴다.  
다음 루비 예제를 보면 Terminator 모듈은 애플리케이션을 종료하는 역할을 한다.  
하지만 실제로 종료하기 전에 모든 감시자에게 애플리케이션이 끝날것이라고 알린다. 감시자는 이런 알림을 이용해 임시 리소스 정리나 데이터 커밋등을 할 수 있다.  
```Ruby
module Terminator
  CALLBACKS = []

  def self.register(callback)
    CALLBACKS << callback
  end

  def self.exit(exit_status)
    CALLBACKS.each {|callback| callback.(exit_status)}
    exit!(exit_status)
  end
end

Terminator.register(-> (status) {puts "callback 1이 #{status} 관측"})
Terminator.register(-> (status) {puts "callback 2가 #{status} 관측"})

Terminator.exit(99)
```
'감시자-감시대상' 패턴은 특히 사용자 인터페이스 시스템에서 널리 쓰이는데, 어떤 상호작용이 일어났다는 것을 애플리케이션에 콜백으로 알려주는 방식을 사용한다.  
하지만 감시자패턴에는 문제가 하나 있는데, 모든 감시자가 감시 대상에 등록되야 되므로 결합이 생긴다.  
더군다나 일반적으로 감시대상이 콜백을 직접 호출하도록 구현하기 떄문에 이 부분이 성능 병목이 될 수 있다.  
동기적(synchronous)처리의  특성상 콜백 실행이 끝날때 까지 감시 대상이 계속 기다려야 하기 때문이다.  
이 문제는 다음 전략인 '게시-구독'으로 해결한다.  

### 게시-구독
이 패턴은 감시자 패턴을 일반화 한 것이다. 동시에 감시자 모델의 결합도를 높이는 문제와 성능 문제도 해결한다.  
게시-구독 모델에는 '게시자'와 '구독자'가 있고 이들은 채널로 연결된다.  
채널은 별도의 코드로 구현되는데, 라이브러리인 경우도 있고 프로세스 혹은 분산 인프라인 경우도 있다.  
각 채널에는 이름이 있고, 구독자는 관심사를 하나 이상의 채널에 등록하고 게시자는 채널에 이벤트를 보낸다.  
감시자 패턴과는 다르게 게시자와 구독자의 통신은 우리의 코드 밖에서 일어나고, 아마 비동기적으로 이루어질 것이다.  
직접 시스템을 구현하는 것도 불가능하지는 않지만, 진짜로 우리가 구현할 일은 거의 없다.  
일반적으로 대부분의 클라우드 서비스가 이러한 게시-구독 서비스를 제공한다.  
이런 서비스를 이용하면 전 세계의 애플리케이션을 연결할 수 있고, 많이 쓰이는 언어는 모두 게시-구독 라이브러리를 하나쯤은 갖추고 있다.  
게시-구독 모델은 추가적인 결합 없이 비동기 이벤트 처리를 구현하기에 아주 좋으며, 다른 기존 코드를 수정하지 않고 이벤트 처리 코드를 추가하거나 교체할 수 있다.  
대신 단점은 게시-구독 모델을 아주 많이 사용하는 시스템에서는 현재 어떤 일이 벌어지고 있는지 파악하기가 힘들다는 것이다.  
게시자가 메시지를 보내는 것을 확인했더라도 어떤 구독자가 그 메시지를 처리하는지 바로 이어서 볼수 없다.  
감시자 패턴과 비교하자면 게시-구독 모델은 공통 인터페이스인 채널을 추상화함으로서 결합도를 줄인 멋진 사례라고 할수 있지만, 그래봤자 메시지 전달 시스템일 뿐이다.  

### 반응형 프로그래밍과 스트림 그리고 이벤트
반응형 프로그래밍의 개념은 값이 바뀌면 그 값을 사용하는 다른 값이 반응하는(react) 것이다.  
이런 데이터 수준의 반응형을 구현할수 있는 프레임워크로는 리액트(react), 뷰(vue.js)등이 있다.  
이벤트를 사용하여 코드가 반응하도록 할수있다는것은 명백하지만 이벤트를 이리저리 연결하는 것도 쉽지는 않은데 그래서 스트림(stream)이 필요하다.  
스트림은 이벤트를 일반적인 자료구조처럼 다룰수 있게 해준다.  
이벤트의 리스트를 다루는 셈이라고 보면 되는데 새로운 이벤트가 도착하면 이 리스트가 길어지는 셈이다.  
스트림은 또한 비동기 적으로 작동할 수도 있는데, 이벤트가 도착했을때 우리의 코드가 이벤트에 응답할 기회를 얻는다.  
다음의 예제에서는 이를 구현한 자바스크립트용 라이브러리인 RxJS를 사용한다.  
```RxJS
import * as Obbservable from 'rxjs'
import { logValues }    from "../rxcommon/logger.js"

let animals = Observable.of("ant", "bee", "cat", "dog", "elk")
let ticker  = Observable.interval(500)

let combined = Observable.zip(animals, ticker)

combined.subscribe(next => logValues(JSON.stringify(next)))
```
첫번째 예제는 두개의 스트림을 받아 하나로 엮는데(zip), 그러면 결과로 새로운 스트림이 생기게 되고 첫번쨰 스트림에서 원소 하나, 
두번째 스트림에서 원소 하나를 가져와서 하나로 묶은것이 새로운 스트림의 원소가 된다.  
첫번째 스트림은 그냥 동물이름 다섯개이고, 두번째 스트림은 500ms마다 이벤트를 발생시키는 반복 타이머다.  
두 스트림이 집(zip)으로 엮였기 때문에 둘 모두에 데이터가 있을 때만 엮인 스트림에 결과가 생기게 되는데, 즉 출력 스트림은 0.5초에 한번씩 결과를 내보낸다.  
실행 결과를 보면
![KakaoTalk_20230809_201957670](https://github.com/jhkman/ProgramProgrammingProgrammer/assets/50142323/9995e22d-8b65-4069-ba06-53d41e745dd5)
정확히 500ms마다 하나씩 스트림에서 이벤트를 받고, 각 이벤트에는 주어진 동물이름과 반복타이머가 생성하는 일련번호가 들어있다.  
일반적으로 이벤트 스트림은 이벤트가 발생할 때마다 채워지는데, 이말은 곧 이벤트를 발생시키는 감시대상들을 병렬적으로 실행시킬 수 있다는 것이다.  
다음 예제는 원격 웹 API를 호출하여 가상의 3, 2, 1이라는 아이디인 사용자 정보를 가져올것이다.  
```RxJS
import * as Obbservable from 'rxjs'
import { mergeMap }     from 'rxJs/operators'
import { ajax }         from 'rxJs/ajax'
import { logValues }    from "../rxcommon/logger.js"

let users = Observable.of(3, 2, 1)
let ticker  = Observable.interval(500)

let result = users.pipe(
  mergeMap((user) => ajax.getJSON('https://reqres.in/api/users/${user}'))
)

result.subscribe(
  resp => logValues(JSON.stringigy(resp.data)),
  err  => console.error(JSON.stringigy(err))
)
```
코드의 내용은 중요치 않다. 결과를 보자
![KakaoTalk_20230809_203043975](https://github.com/jhkman/ProgramProgrammingProgrammer/assets/50142323/c2aadf3a-8f58-4755-98b9-f4835f6e6b63)
시간을 표시하는 부분을 눈여겨 보면, 세개의 요청 즉 세개의 개별 스트림이 병렬적으로 처리되었다.  
첫번째는 아이디 2에대한것이 82ms만에 도착하고, 다른 둘은 각각 그후 50ms, 51ms 후 도착했다.

#### 이벤트 스트림은 비동기 컬렉션
첫번째 예제에서는 users에 담긴 사용자 아이디 목록은 고정되어 있었지만 꼭 그래야 하는 것은 아니다.  
이벤트 스트림은 동기적 처리와 비동기적 처리를 하나의 편리한 공통 API로 감싸서 통합한다.
