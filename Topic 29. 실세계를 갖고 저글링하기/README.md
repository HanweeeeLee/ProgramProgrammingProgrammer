# Topic 29. 실세계를 갖고 저글링하기
우리가 작성하는 애플리케이션은 맡은 일을 어떻게든 수행해야 한다.  
이번장은 반응적인(Responsive) 애플리케이션을 작성하는 법을 다룬다.  

## 이벤트
이벤트는 무언가 정보가 있다는것을 의미한다.  
어디에서 온 것이든 애플리케이션을 이런 이벤트에 반응하도록, 그에 기반해서 하는 일을 조절하도록 만들면 더 잘 작동하는 애플리케이션이 탄생할 것이다.  
어떻게 이벤트에 잘 반응하는 애플리케이션을 만들수 있을까? 우리를 도와줄 네가지 전략을 살펴보자
1. 유한 상태 기계
2. 감시자(Observer) 패턴
3. 게시-구독
4. 반응형 프로그래밍과 스트림

### 유한상태 기계(Finite State Machine, FSM)

#### 실용주의 FSM 해부학
기본적으로 상태 기계는 이벤트를 어떻게 처리할지 정의한 명세일 뿐이다.  
정해진 상태들이 있고 그중 하나가 '현재 상태'다. 상태마다 그 상태일 때 의미가 있는 이벤트들을 나열하고, 이벤트별로 시스템의 다음 '현재 상태'를 정의한다.  
예를들어 여러 조각으로 나뉜 메시지를 웹소켓으로 받는다고 할떄, 첫번째 메시지는 헤더다. 그 다음에는 데이터 메시지가 몇개든 올수 있다.  
마지막으로 끝을 나타내는 트레일러 메시지가 온다 이를 FSM으로 표현해보면 다음과 같다.  
![KakaoTalk_20230808_233051268](https://github.com/jhkman/ProgramProgrammingProgrammer/assets/50142323/79802a34-df61-4063-8b19-c4ec36cdec6b)
'초기 상태' 에서 시작해서, 헤더 메시지를 받으면 '메시지 수신 중'상태로 이행한다.  
별표가 붙은 선은 초기상태에서 헤더가 아닌 메시지를 받으면 '오류' 상태로 이행하고 끝난다는 것이다.  
'메시지 수신 중'상태에서는 두가지 메시지를 받을수 있는데, 데이터 메시지를 받으면 현 상태에서 계속 메시지를 받고, 트레일러 메시지를 받으면 '완료' 상태로 이행한다.  
그밖의 다른 메시지를 받으면 '오류' 상태로 이행한다.  
FSM의 장점은 FSM을 오로지 데이터만으로 표현할 수 있다는 것이다.  
![KakaoTalk_20230808_233447804](https://github.com/jhkman/ProgramProgrammingProgrammer/assets/50142323/fa8403b3-3dcb-4675-bdfd-ce8deebb4d23)
각 행은 상태를 나타낸다. 이벤트 처리 방법을 알아내려면 먼저 현재 상태를 나타내는 행을 찾은 다음 발생한 이벤트를 나타내는 열을 찾으면 된다.  
찾은 칸의 내용이 다음 상태다. 코드로 표현해도 똑같이 간단하다.
```Ruby
TRANSITIONS = {
  initial: {header: : reading},
  reading: {data: :reading, trailer: :done}
}

state = :initial

while state != :done && state != :error
  msg = get_next_message()
  state= TRANSITIONS[state][msg.msg_type] || :error
end
```
상태간의 이행을 구현하는 코드는 열번째 줄이다. 상태이행 표에서 현재 상태를 먼저 찾고, 그 안에서 메시지 타입을 다시 찾아서 새로운 상태를 구했다.  
만약 해당하는 상태가 없다면 상태는 :error로 바뀐다.  

#### 상태 기계는 시작일 뿐
상태기계가 이벤트와 관련된 모든 문제를 해결하지는 못한다. 그러니 이벤트로 곡예를 펼치는 다른 방법으로 넘어가보자.  

### 감시자 패턴
'감시자 패턴'은 이벤트를 발생시키는쪽인 '감시 대상'과 이런 이벤트에 관심이 있는 클라이언트인 '감시자'로 이루어진다.  
감시자는 자신이 관심 있는 이벤트를 감시 대상에 등록한다. 보통은 호출될 함수의 참조도 등록할때 함께 넘긴다.  
나중에 해당 이벤트가 발생시 감시대상은 등록된 감시자 목록을 보면서 함수들을 일일히 호출한다. 이때 발생한 이벤트를 감시자 함수의 인자로 넘긴다.  
다음 루비 예제를 보면 Terminator 모듈은 애플리케이션을 종료하는 역할을 한다.  
하지만 실제로 종료하기 전에 모든 감시자에게 애플리케이션이 끝날것이라고 알린다. 감시자는 이런 알림을 이용해 임시 리소스 정리나 데이터 커밋등을 할 수 있다.  
```Ruby
module Terminator
  CALLBACKS = []

  def self.register(callback)
    CALLBACKS << callback
  end

  def self.exit(exit_status)
    CALLBACKS.each {|callback| callback.(exit_status)}
    exit!(exit_status)
  end
end

Terminator.register(-> (status) {puts "callback 1이 #{status} 관측"})
Terminator.register(-> (status) {puts "callback 2가 #{status} 관측"})

Terminator.exit(99)
```
'감시자-감시대상' 패턴은 특히 사용자 인터페이스 시스템에서 널리 쓰이는데, 어떤 상호작용이 일어났다는 것을 애플리케이션에 콜백으로 알려주는 방식을 사용한다.  
하지만 감시자패턴에는 문제가 하나 있는데, 모든 감시자가 감시 대상에 등록되야 되므로 결합이 생긴다.  
더군다나 일반적으로 감시대상이 콜백을 직접 호출하도록 구현하기 떄문에 이 부분이 성능 병목이 될 수 있다.  
동기적(synchronous)처리의  특성상 콜백 실행이 끝날때 까지 감시 대상이 계속 기다려야 하기 때문이다.  
이 문제는 다음 전략인 '게시-구독'으로 해결한다.  

### 게시-구독
이 패턴은 감시자 패턴을 일반화 한 것이다. 동시에 감시자 모델의 결합도를 높이는 문제와 성능 문제도 해결한다.  
게시-구독 모델에는 '게시자'와 '구독자'가 있고 이들은 채널로 연결된다.  
채널은 별도의 코드로 구현되는데, 라이브러리인 경우도 있고 프로세스 혹은 분산 인프라인 경우도 있다.  
각 채널에는 이름이 있고, 구독자는 관심사를 하나 이상의 채널에 등록하고 게시자는 채널에 이벤트를 보낸다.  
감시자 패턴과는 다르게 게시자와 구독자의 통신은 우리의 코드 밖에서 일어나고, 아마 비동기적으로 이루어질 것이다.  
직접 시스템을 구현하는 것도 불가능하지는 않지만, 진짜로 우리가 구현할 일은 거의 없다.  
일반적으로 대부분의 클라우드 서비스가 이러한 게시-구독 서비스를 제공한다.  
이런 서비스를 이용하면 전 세계의 애플리케이션을 연결할 수 있고, 많이 쓰이는 언어는 모두 게시-구독 라이브러리를 하나쯤은 갖추고 있다.  
게시-구독 모델은 추가적인 결합 없이 비동기 이벤트 처리를 구현하기에 아주 좋으며, 다른 기존 코드를 수정하지 않고 이벤트 처리 코드를 추가하거나 교체할 수 있다.  
대신 단점은 게시-구독 모델을 아주 많이 사용하는 시스템에서는 현재 어떤 일이 벌어지고 있는지 파악하기가 힘들다는 것이다.  
게시자가 메시지를 보내는 것을 확인했더라도 어떤 구독자가 그 메시지를 처리하는지 바로 이어서 볼수 없다.  
감시자 패턴과 비교하자면 게시-구독 모델은 공통 인터페이스인 채널을 추상화함으로서 결합도를 줄인 멋진 사례라고 할수 있지만, 그래봤자 메시지 전달 시스템일 뿐이다.  

### 반응형 프로그래밍과 스트림 그리고 이벤트

### 어디에나 이벤트가 있다
