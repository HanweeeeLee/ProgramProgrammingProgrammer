# Topic 41. 테스트로 코딩하기
테스트의 중요한 가치는 무엇일까? 
> 테스트는 버그를 찾기 위한 것이 아니다.

테스트의 주요한 이득은 테스트를 실행할 때가 아니라 테스트에 대해 생각하고, 테스트를 작성할 때 생긴다고 믿는다.

## 테스트에 대해 생각하기
예시를 들어보자. 만약 동영상 웹사이트에서 사용할 데이터베이스 조회 코드를 작성해야 한다.  
한주에 동영상을 10개 넘게 보는 사람 목록을 조회하려 한다.  
```python
def return_avid_viewers do
  # ... 흠... 열광적인(avid) 시청자(viewer)...
end
```
일단 함수를 모두 작성했다고 가정해 보자. 이제 테스트를 해야한다.  
일단 테스트 데이터를 사용해야 할 것이다. 우리가 관리하는 데이터베이스를 연결할 것이다.  
```python
def return_avid_users(db) do
```
그 다음으로는 어떻게 테스트 데이터를 채울지 생각해야 한다. 요구사항은 '한주에 동영상을 10개 넘게 보는 사람 목록' 이다.  
도움이 될만한 필드가 있는지 DB 스키마를 확인해 보아야 한다. 그럴싸한 필드를 두개 찾았다. opened_video와 completed_video다.  
테스트 데이터를 작성하려면 어떤 필드를 쓸지 알아야 하는데, 우리는 요구사항이 정확하게 무엇을 의미하는지 모르고 담당자는 연락이 안된다.  
필드 이름을 매개 변수로 넘기는 꼼수로 쓰자. 그러면 일단 현재 코드의 테스트가 가능하다.  
```python
def return_avid_users(db, qualifying_field_name) do
```
테스트에 대해 생각하는 것으로 시작했는데 코드 한줄 쓰지 않고도 두 가지 발견을 했다. 그리고 이를 바탕으로 우리 메서드의 API를 변경했다.

## 테스트가 코딩을 주도한다.
이전 예시에서 테스트에 대해 생각함으로서 우리 코드의 결합도는 낮추고 유연성은 올릴수 있었다.  
우리 메서드의 테스트 작성에 대해 생각함으로서 코드의 작성자가 아니라 사용자인 것처럼 메서드를 외부의 시선으로 보게 되었다.  
이것이 테스트가 주는 가장 큰 이득일지 모른다. 테스트는 우리의 코딩을 인도하는 필수 피드백이다.  
다른 코드와 긴밀하게 결합된 함수나 메서드는 테스트하게 힘들다. 메서드를 실행하기도 전에 환경 구성을 한참 해야 하기 때문이다.  
즉, 무언가를 테스트하기 좋게 만들면 결합도도 낮아진다.  

## 테스트 주도 개발
테스트를 먼저 생각하는 것의 이점이 많다보니 테스트를 먼저 작성하자고 주장하는 프로그래머들이 있는데,  
이들은 테스트 주도 개발(TDD)라는 기법을 사용한다.  
TDD의 기본 주기는 다음과 같다.  
1. 추가하고 싶은 작은 기능 하나를 결정한다.
2. 그 기능이 구현되었을 때 통과하게 될 테스트를 하나 작성한다.
3. 테스트를 실행한다. 다른 테스트는 통과하고 방금 추가한 테스트 딱 하나만 실패해야 한다.
4. 실패하는 테스트를 통과시킬 수 있는 최소한의 코드만 작성한다. 그리고 이제는 모든 테스트가 통과하는지 확인한다.
5. 코드를 리팩터링한다. 방금 작성한 테스트나 함수를 개선할 수 있는 부분이 없는지 살펴본다. 개선한 후에도 테스트가 계속 통과하는지 확인한다.

TDD의 발상의 핵심은 이 반복주기가 기껏해야 몇분정도로 매우 짧아야 한다는 것이다.  
따라서 끊임없이 테스트 작성과 테스트를 통과하게 만들기를 반복하게 된다.  
어떻게든 TDD를 실천하라. 하지만 도중에 이따금 멈추어 큰 그림을 살피는 것을 잊지 말라.  

## TDD:목표가 어디인지 알아야 한다.
TDD의 장점은 전체 문제를 완전히 파악하기 힘들 때 한 번에 테스트 하나씩 작은 단계들을 밟는 것이다.  
하지만 이런 접근 방법이 잘못된 길로 인도할 수도 있다.  
명백히 테스트는 개발을 이끌어 나가는 데 도움이 된다. 하지만 나아갈 때마다 목적지를 떠올리지 않으면 계속 같은 자리만 빙빙 돌게 될 수도 있다.  

## 다시 코드로
컴포넌트 기반 개발은 오랫동안 소프트웨어 개발이 추구해 온 목표 였는데,  
기본 발상은 일반화된 IC칩들을 조합하여 회로를 구성하는 것처럼 소프트웨어 컴포넌트들을 가져다 조립해서 쓸 수 있어야 한다는 것이다.  
칩은 테스트 할수 있도록 설계된다. 공장에서나 회로에 꼽았을 때만 아니라, 제품으로 설치된 현장에서도 테스트 할수 있도록 설계된다.  
소프트웨어에서도 똑같이 할 수 있다. 소프트웨어를 만들때, 처음부터 테스트가 가능하도록 만들고,  
코드들을 서로 연결하기 전에 코드를 하나하나 철저하게 테스트해야만 한다.  

## 단위 테스트
하드웨어의 칩 차원 테스트는 대체로 소프트웨어의 '단위 테스트'에 해당한다고 볼 수 있다.  
두 경우 모두 각 모듈의 동작을 검증하기 위해 다른 것들로부터 분리시켜 놓고 테스트를 수행한다.  
모듈을 통제된 환경에서 철저하게 테스트하고 나면, 넓은 바깥세상에서 그 모듈이 어떻게 행동할지 더 잘 알게 될 것이다.  
소프트웨어 단위 테스트란 어떤 모듈에게 이것저것을 시켜보는 코드를 가리킨다.  
일반적으로 단위 테스트는 인위적인 환경을 구축한 다음, 테스트할 모듈의 루틴들을 호출한다.  
그 다음 반환된 결과들을 이미 알고 있는 값과 비교해 보거나 똑같은 테스트를 이전에 돌렸을 때 나온 값과 비교하여 올바른지 검사한다.  
동일한 테스트를 코드 수정 후 다시 돌려보는 것을 회귀테스트(regression testing)라고 한다.  

## 계약을 지키는지 테스트하기
우리는 단위 테스트를 '계약을 잘 지키는지 보는 테스트' 라고 여긴다.  
우리는 어떤 코드 단위가 자신이 맺은 계약을 지키는지 확인하는 테스트 케이스를 작성하고자 한다.  
이런 테스트는 두가지를 알려주는데, 하나는 코드가 계약을 지키는지 여부고, 다른 하나는 코드로 표현된 계약의 의미가 우리가 생각한 것과 일치하는지 여부다.  
계약을 잘 지키는지 확인하는 테스트를 강조함으로서 프로젝트에서 이후에 벌어질지 모를 재앙을 피하려고 노력해야한다.  

## 임시 테스트
임시테스트는 우리가 직접 코드를 이리저리 찔러보는 것이다.  
console.log() 한줄 일수도 있고 디버거나 IDE 환경에 직접 실행하면서 입력하는 코드 조각일 수도 있다.  
디버깅 작업이 끝나면 이런 임시 테스트를 정식 테스트의 형태로 만들어 두어야 한다.  
여러분이 만든 테스트를 그냥 버리지 말고 기존의 단위 테스트 군단에 합류시켜라.  

## 테스트 접점 만들기
아무리 테스트를 잘 갖추었어도 모든 버그를 발견할 수는 없다. 실제 서비스 환경에 있는 무언가가 숨어 있던 버그를 기어나오게 만든다.  
이 말은 소프트웨어를 배포한 후에도 테스트할 일이 자주 생긴다는 것이다.  
소프트웨어에는 회로판처럼 테스트용 핀은 없지만 어떤 모듈의 내부 상태를 디버거 없이 다양한 형태로 볼 수 있는 방법을 제공할 수도 있다.  
로그 파일에 쌓이는 trace메시지가 이런 메커니즘 가운데 하나다.  
또다른 매커니즘으로는 단축키 조합이나 숨겨진 URL 방식이 있는데, 특정한 키 조합을 누르거나 특정 URL에 접속하면  
상태정보와 그 외의 것들이 들어있는 진단 제어 창이 열리게 만드는 것이다.  

## 테스트 문화
우리가 작성하는 모든 소프트웨어는 언젠가는 테스트된다. 우리나 우리 팀이 테스트하지 않으면 결과적으로 사용자들이 테스트하게 된다.  
그러니 소프트웨어를 철저하게 테스트할 계획을 세우는 것이 좋다. 약간의 선견지명으로 유지 보수 비용과 컴플레인 수를 크게 줄일수 있다.  
우리가 선택할 선택지는 크게 "테스트 먼저", "코드와 테스트를 함께", "테스트하지 않음" 셋 중 하나다.  
"테스트 먼저"가 최상의 선택일 것이다. TDD도 여기에 포함된다.  
하지만 때에 따라 테스트를 먼저 쓰기가 어렵거나 의미가 없을 수 있다. 그러면 "코드와 테스트를 함께"가 대안이 될 수 있다.  
코드를 조금 작성하고, 이리저리 만지다가 테스트를 작성하라. 그리고 다시 코드로 넘어간다.  
최악의 선택은 흔히 말하는 "나중에 테스트" 라는 것인데, 완전 헛소리다. "나중에 테스트는" 곧 "테스트하지 않음"이란 뜻이다.  
테스트 코드를 다른 제품 코드와 마찬가지로 다뤄라. 결합도를 낮추고, 꺠끗하고 견고하게 유지하라.  
테스트는 프로그래밍의 일부다. 다른 사람이나 부서에 떠넘길수 있는것이 아니다. 
